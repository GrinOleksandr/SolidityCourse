<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hello MetaTx demo</title>
</head>

<body>
<div>
    <h1>Hello MetaTx demo</h1>
    <button id="enableEthereumButton">Enable Ethereum</button>
</div>
<div>
    <h3>Sign Data</h3>
    <button type="button" id="signDataButton">Sign Data</button>
    <input id="signData" value="hello" />
</div>
<div>
    <h3>Generage `SafeMint` Metatransaction</h3>
    <button type="button" id="genMintMetaTxButton">Generate SafeMint MetaTx</button>
</div>
<div>
    <h3>Sign Typed Data</h3>
    input:
    <div>
      <span>
        from<input id="metaTxFrom" value="0x" />
      </span>
    </div>
    <div>
      <span>
        to<input id="metaTxTo" value="0x" />
      </span>
    </div>
    <div>
      <span>
        value<input id="metaTxValue" value="0" />
      </span>
    </div>
    <div>
      <span>
        gas<input id="metaTxGas" value="0" />
      </span>
    </div>
    <div>
      <span>
        nonce<input id="metaTxNonce" value="0" />
      </span>
    </div>
    <div>
      <span>
        data<input id="metaTxData" value="0x" />
      </span>
    </div>
    output:
    <div>
      <span>
        signature<input id="metaTxSignature" value="" />
      </span>
    </div>
    <button type="button" id="signTypedDataButton">Sign Typed Data</button>
    <button type="button" id="executeMetaTxButton">Execute metaTx</button>
</div>

</body>

<script src="https://cdnjs.cloudflare.com/ajax/libs/web3/3.0.0-rc.5/web3.min.js" integrity="sha512-jRzb6jM5wynT5UHyMW2+SD+yLsYPEU5uftImpzOcVTdu1J7VsynVmiuFTsitsoL5PJVQi+OtWbrpWq/I+kkF4Q==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
<!--<script src="https://cdn.jsdelivr.net/npm/eth-sig-util@3.0.1/dist/index.min.js"  crossorigin="anonymous" referrerpolicy="no-referrer"></script>-->
<script>
  var ethereum
  if (typeof window.ethereum !== 'undefined') {
    console.log('MetaMask is installed!')
    ethereum = window.ethereum
  }

  const MetaTxABI = [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct MinimalForwarder.ForwardRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct MinimalForwarder.ForwardRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ]

  const vendorAbi = [
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct MinimalForwarder.ForwardRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "buyTokensForDAIOnBehalf",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct MinimalForwarder.ForwardRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "execute",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        },
        {
          "internalType": "bytes",
          "name": "",
          "type": "bytes"
        }
      ],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "from",
          "type": "address"
        }
      ],
      "name": "getNonce",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "from",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "to",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "value",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "gas",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "nonce",
              "type": "uint256"
            },
            {
              "internalType": "bytes",
              "name": "data",
              "type": "bytes"
            }
          ],
          "internalType": "struct MinimalForwarder.ForwardRequest",
          "name": "req",
          "type": "tuple"
        },
        {
          "internalType": "bytes",
          "name": "signature",
          "type": "bytes"
        }
      ],
      "name": "verify",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [{
        "internalType": "address",
        "name": "tokenContractAddress",
        "type": "address"
      }, {
        "internalType": "address",
        "name": "_DAITokenContractAddress",
        "type": "address"
      }],
      "stateMutability": "nonpayable",
      "type": "constructor"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "address",
        "name": "previousAdmin",
        "type": "address"
      }, {
        "indexed": false,
        "internalType": "address",
        "name": "newAdmin",
        "type": "address"
      }],
      "name": "AdminChanged",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": true,
        "internalType": "address",
        "name": "beacon",
        "type": "address"
      }],
      "name": "BeaconUpgraded",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "string",
        "name": "message",
        "type": "string"
      }],
      "name": "Log",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "bytes",
        "name": "message",
        "type": "bytes"
      }],
      "name": "LogBytes",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "uint256",
        "name": "number",
        "type": "uint256"
      }],
      "name": "MyTokensTransfered",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": true,
        "internalType": "address",
        "name": "previousOwner",
        "type": "address"
      }, {
        "indexed": true,
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }],
      "name": "OwnershipTransferred",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "uint256",
        "name": "price",
        "type": "uint256"
      }],
      "name": "PriceUpdated",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": false,
        "internalType": "uint256",
        "name": "number",
        "type": "uint256"
      }],
      "name": "RandomNumberUpdated",
      "type": "event"
    }, {
      "anonymous": false,
      "inputs": [{
        "indexed": true,
        "internalType": "address",
        "name": "implementation",
        "type": "address"
      }],
      "name": "Upgraded",
      "type": "event"
    }, {
      "inputs": [],
      "name": "buyTokens",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }, {
      "inputs": [{
        "internalType": "uint256",
        "name": "amountToBuy",
        "type": "uint256"
      }],
      "name": "buyTokensForDAI",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    // {
    //   "inputs": [{
    //     "internalType": "uint256",
    //     "name": "amountToBuy",
    //     "type": "uint256"
    //   },
    //   //   {
    //   //   "internalType": "address",
    //   //   "name": "buyer",
    //   //   "type": "address"
    //   // }
    //   ],
    //   "name": "buyTokensForDAIOnBehalf",
    //   "outputs": [],
    //   "stateMutability": "nonpayable",
    //   "type": "function"
    // }  ,
    {
      "inputs": [],
      "name": "owner",
      "outputs": [{
        "internalType": "address",
        "name": "",
        "type": "address"
      }],
      "stateMutability": "view",
      "type": "function"
    }, {
      "inputs": [],
      "name": "renounceOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }, {
      "inputs": [{
        "internalType": "address",
        "name": "newOwner",
        "type": "address"
      }],
      "name": "transferOwnership",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }, {
      "inputs": [{
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      }],
      "name": "upgradeTo",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }, {
      "inputs": [{
        "internalType": "address",
        "name": "newImplementation",
        "type": "address"
      }, {
        "internalType": "bytes",
        "name": "data",
        "type": "bytes"
      }],
      "name": "upgradeToAndCall",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    }];

  const vendorAddress = '0xE5d81078Dfd342ecA344C6237C9d3B1B22835FaD';

  const ethereumButton = window.document.getElementById("enableEthereumButton")
  const signButton = window.document.getElementById("signDataButton")
  const genMintMetaTxButton = window.document.getElementById("genMintMetaTxButton")
  const signTypedButton = window.document.getElementById("signTypedDataButton")
  const executeMetaTxButton = window.document.getElementById("executeMetaTxButton")

  var accounts
  ethereumButton.addEventListener('click', () => {
    event.preventDefault()
    //Will Start the metamask extension
    accounts = ethereum.request({
      method: 'eth_requestAccounts'
    }).then(() => {
      console.log('chainId: ', ethereum.chainId)
      if (ethereum.chainId != '0x4') {
        ethereum.request({
          method: 'wallet_switchEthereumChain',
          params: [{ chainId: '0x4' }],
        })
      }
    })
  })

  signButton.addEventListener('click', () => {
    event.preventDefault()
    signDataInput = window.document.getElementById('signData')
    const signature = ethereum.request({
      method: 'personal_sign',
      params: [
        ethereum.selectedAddress,
        signDataInput.value,
      ],
    })
    console.log('signature: ', signature)
  })

  genMintMetaTxButton.addEventListener('click', async () => {
    event.preventDefault()

    const req = await genMintNFTMetaTx(vendorAddress)
    window.document.getElementById('metaTxFrom').value = req.from
    window.document.getElementById('metaTxTo').value = req.to
    window.document.getElementById('metaTxValue').value = req.value
    window.document.getElementById('metaTxGas').value = req.gas
    window.document.getElementById('metaTxNonce').value = req.nonce
    window.document.getElementById('metaTxData').value = req.data
  })

  signTypedButton.addEventListener('click', (event) => {
    event.preventDefault()
    req = getReqFromForm()
    signMetaTx(req)
  })

  executeMetaTxButton.addEventListener('click', async (event) => {
    event.preventDefault()
    const req = getReqFromForm()
    const signature = window.document.getElementById('metaTxSignature').value
    const verification = await verifyMetaTx(vendorAddress, req, signature)
    if ( verification !== true) {
      alert(`meta transaction is invalid!! ${verification}`)
      return
    }

    await executeMetaTx(vendorAddress, req, signature)
  })
</script>

<script type="text/javascript">

  const genMintNFTMetaTx = async (vendorAddress) => {
    var web3 = new Web3(ethereum)
    const bn1e18 = web3.utils.toBN(1e18);

    // const vendorAddress = '0x5e6EefBCda5869802E9038011344d36C65d6C47E';
    var vendorContract = new web3.eth.Contract(vendorAbi, vendorAddress)
    const from = ethereum.selectedAddress
    const callData = vendorContract.methods.buyTokensForDAI(web3.utils.toBN(17).mul(bn1e18)).encodeABI()
    // const gas = await vendorContract.methods.buyTokensForDAI(web3.utils.toBN(17).mul(bn1e18)).estimateGas({from: from})

    return {
      from: from,
      to: vendorAddress,
      value: '0',
      gas: 1000000,
      nonce: await getMetaTxNonce(),
      data: callData,
    }
  }

  const getMetaTxNonce = async () => {
    var web3 = new Web3(ethereum)

    var vendorContract = new web3.eth.Contract(vendorAbi, vendorAddress)
    return await vendorContract.methods.getNonce(ethereum.selectedAddress).call()
  }

  const signMetaTx = async (req) => {
    const msgParams = JSON.stringify({
      domain: {
        // Defining the chain aka Rinkeby testnet or Ethereum Main Net
        chainId: ethereum.chainId,
        // Give a user friendly name to the specific contract you are signing for.
        name: 'MinimalForwarder',
        // If name isn't enough add verifying contract to make sure you are establishing contracts with the proper entity
        verifyingContract: vendorAddress,
        // Just let's you know the latest version. Definitely make sure the field name is correct.
        version: '0.0.1',
      },

      // Defining the message signing data content.
      message: req,
      // Refers to the keys of the *types* object below.
      primaryType: 'ForwardRequest',
      types: {
        // TODO: Clarify if EIP712Domain refers to the domain the contract is hosted on
        EIP712Domain: [{
          name: 'name',
          type: 'string'
        },
          {
            name: 'version',
            type: 'string'
          },
          {
            name: 'chainId',
            type: 'uint256'
          },
          {
            name: 'verifyingContract',
            type: 'address'
          },
        ],
        // Refer to PrimaryType
        ForwardRequest: [{
          name: 'from',
          type: 'address'
        },
          {
            name: 'to',
            type: 'address'
          },
          {
            name: 'value',
            type: 'uint256'
          },
          {
            name: 'gas',
            type: 'uint256'
          },
          {
            name: 'nonce',
            type: 'uint256'
          },
          {
            name: 'data',
            type: 'bytes'
          },
        ],
      },
    })

    var from = ethereum.selectedAddress

    var params = [from, msgParams]
    var method = 'eth_signTypedData_v4'

    const signature = await ethereum
      .request({
        method,
        params,
        from,
      })

    window.document.getElementById('metaTxSignature').value = signature
    return signature
  }

  const verifyMetaTx = async (vendorAddress, req, signature) => {
    var web3 = new Web3(ethereum)

    var vendorContract = new web3.eth.Contract(vendorAbi, vendorAddress)
    return await vendorContract.methods.verify(req, signature).call()
  }

  const executeMetaTx = async (vendorAddress, req, signature) => {
    var web3 = new Web3(ethereum)

    var vendorContract = new web3.eth.Contract(vendorAbi, vendorAddress)
    return await vendorContract.methods.buyTokensForDAIOnBehalf(req, signature).send({from: ethereum.selectedAddress})
  }

  const getReqFromForm = () => {
    return {
      from: window.document.getElementById('metaTxFrom').value,
      to: window.document.getElementById('metaTxTo').value,
      value: window.document.getElementById('metaTxValue').value,
      gas: window.document.getElementById('metaTxGas').value,
      nonce: window.document.getElementById('metaTxNonce').value,
      data: window.document.getElementById('metaTxData').value,
    }
  }
</script>

</html>